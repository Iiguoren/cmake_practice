# vscode编译基础
## c/c++环境
在vscode配置c/c++环境可以通过安装C/C++,C/C++ Themes,C/C++ Extension Pack 三个扩展配置开发环境，C/C++扩展安装完后，会对应有launch.json、tasks.json、c_cpp_properties.json等文件,下面介绍Tasks.json、Launch.json、C_cpp_properties.json文件的配置。
### Tasks.json
*tasks.json 用来配置编译任务*（前提是有对应的c++编译器，如MinGW），该文件配置后我们写的代码才能被C/C++编译器正常编译。在确保安装必要的插件之后，单击vscode菜单栏的Terminal栏，单击红箭头所指的Configure Tasks...选项，弹出select a task to configure的菜单,选择要生成的task文件模板。之后生成一个.vscode文件夹以及里面的tasks.json。注意编译器的类型。
```cpp
{
  "tasks": [
    {
      "type": "cppbuild",//任务类型,可以取cppbuild、shell、process，三种执行时稍有差异，这里选择默认cppbuild。
      "label": "build task 1",//任务标签(标记)，也即任务名称，任务名称要和launch.json里的"preLaunchTask"值对应一致。
      "command": "D:\\rewr\\mingw64\\bin\\gcc.exe",//编译器及其路径，.c用gcc.exe编译器，.cpp用g++.exe编译器,还可以是后面即将讲到的Cmake、make。
      "args": [
        "-fdiagnostics-color=always",
        "-g",//生成和调试有关的信息，launch.json会用到这些信息。
        "${file}",//编译当前打开的.c(或.cpp)文件。
        "-o",//指定编译的输出，windows系统下输出.exe文件,见下行。
        //下面是windows系统下输出.exe文件及其路径,应该与launch.json的"program"的值代表的路径一致。
        "${workspaceFolder}\\${fileBasenameNoExtension}.exe"
      ],
      "options": {
        "cwd": "${workspaceFolder}"//当前工作目录(路径)。
      },
      "problemMatcher": ["$gcc"],//使用gcc的问题匹配器。
      "group": {
        "kind": "build",
        "isDefault": true
      },
      "detail": "Task generated by Debugger."
    }
  ],
  "version": "2.0.0"
}
```
```cpp
"args": [
        "-fdiagnostics-color=always",
        "-g",//生成和调试有关的信息，launch.json会用到这些信息。
        "${file}",//编译当前打开的.c(或.cpp)文件。
        "-o",//指定编译的输出，windows系统下输出.exe文件,见下行。
        //下面是windows系统下输出.exe文件及其路径,应该与launch.json的"program"的值代表的路径一致。
        "${workspaceFolder}\\${fileBasenameNoExtension}.exe"
      ],
```
等同于`g++ ${file} -o ${fileDirname}\${fileBasenameNoExtension}.exe`，只能编译当前文件，但当前文件只使用了#include 的头文件中的内容时也可以编译成功。但如果使用了cpp文件的生成内容就编译失败，必须修改"${file}"。
例如：
```cpp
#include <iostream>
#include "../include/listnode.h"

class linkedlistStack{
    private:
    listnode *stacktop;
    int stksize;
    
    public:
    linkedlistStack(){
        stacktop = nullptr;
        stksize = 0;
    }
```
使用了listnode.h
```cpp
#ifndef LISTNODE_H
#define LISTNODE_H

#include <iostream>

// 定义 listnode 结构体
struct listnode{
    int value;
    listnode *next;

    listnode(int num) : value(num), next(nullptr) {};
    ~listnode(){};
};

// 函数声明
void insert(listnode *n0, listnode *p);
void printlistnode(listnode *head);
listnode* find(listnode *n0, int val);

#endif // LISTNODE_H
```
只是用了类的定义，没有使用函数就可以编译，如果使用了listnode的函数部分就不能编译成功。